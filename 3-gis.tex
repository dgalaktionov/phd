\part{GIS interface}
\chapter{Previous concepts}
    In order to develop a usable interface, we must rely on a map based representation that works with geographic information. Therefore, in this chapter we shall introduce the basic concepts of \gls{gis} in order to provide a context for this part of our contribution.

    \section{GIS interfaces}
	Because I have a web interface with leaflet after all.

\chapter{GIS interface for public transportation networks}
\label{sec:gis}
	While in the previous part of this work we have presented compact representations that are capable of efficiently handling large collections of trips over both streets and public transportation networks, in order for it to be actually usable by city management and network administrators a front-end interface must be conceived.
	
	In order to facilitate this kind of analysis, we have developed a proof-of-concept map-based interface based on \gls{gis} and web technologies called \textbf{Trippy}, that allows to exploit some of the capabilities of \gls{xctr} to visualize and query transport demand information over a real transportation network. This constitutes a tool is designed to aid the decision-making process for a public transportation company, and can be easily adapter for different networks and use cases.
	
	In this chapter, we will begin by contextualizing the use case in more detail. After that, we provide an overview of our architecture, both from a functional perspective and a technical one. After that, we will present our API for querying the underlying structure, and finally our prototype user interface.
	
	\section{Motivation}
	\label{sec:gis:intro}
    Collecting historic locations and movement patterns is currently a hot topic, as more mobile phone corporations, car companies, and other organizations are trying to get advantage on the market through these modern initiatives. While users are tracked and benefit of their services (avoiding traffic congestion, locating restaurants and monuments, etc. on Google Maps; getting the best route on public transport to go somewhere or getting real-time schedule for a bus/train line, etc) those companies are also obtaining valuable data that can be exploited to obtain a profit or to improve the assignment of their resources (e.g., personalized recommendations and advertising, estimating the number of passengers and consequently the number of trains or buses that are required to support all the passengers that will use a line today, etc).
    
    If we focus in public transport, such as buses or trains, we find that most transport companies have been focused mainly on providing helpful information to their passengers regarding the existing offer, hence providing non only information related to their transport network (e.g. maps with the lines, their schedule, etc.) but also, in many cases, real-time information with the actual position of a vehicle, remaining time to destination, remaining time until next vehicle arrives, etc. 
    However, although there is also an increasing interest on gathering actual information regarding what users demand from the public transport and how they use their services, to the best of our knowledge, there are no final end-user tools that have tackled both the problems of: {\em (i)} effectively handling the huge amount of data that arises when we track all the user's trips (e.g. within a large city) and {\em (ii)} efficiently exploiting the underlying information.
    %Obtaining such  data necessarily required using some technology to track user's movements along the transport network. Currently, it is not uncommon to find cities having a smart card system \cite{smartCards00}, where each user has a personal public transport card with which he or she can pay for trips over several means of transport (bus, subway, etc) and also to switch between them. The use of these smart cards lets the transportation system to know where and when an individual started a trip, which provides valuable information for the administrators of the system. Indeed, the ending stop of a trip can be also estimated from boarding records alone \cite{wang2011review, alsger2016validating}.
    %Several works have also been presented regarding how travelers switch lines or where they finish their trips in order to completely track down any traveler \cite{daniil18,MUNIZAGA2012x}.  This new available information has been exploited in several scopes. For example, to gather the preferences of users on the chosen mean of public transportation to travel through a city \cite{publicTrans17}, to monitor urban traffic \cite{trafficMonit17}, or to study the traffic effects of the congestion charges introduced in some urban areas around the world \cite{congestion15}. However, to the best of our knowledge, there are no final end-user tools that have tackled both the problems of: {\em (i)} effectively handling the huge amount of data that arises when we track all the user's trips (e.g. within a large city) and {\em (ii)} efficiently exploiting the underlying information.
    
    %\ojo{Meter de alguna forma que tantos viajes, puntos de subida etc etc es big data y no hay ninguna olución final implementada ESCALABLE que permita tratar estos datos EN PROFUNDIDAD (HASTA AHORA que nosotros hemos resuelto el  puzzle)}
    
    
    Therefore, we are focusing on a solution to query and visualize historical records of aggregated patterns of movement from the travelers of a transportation network. While there exist popular solutions such as Google Maps to accurately calculate optimal multi-modal routes and even monitor the real time condition of the transportation networks, as indicated above, these systems only manage information about the {\em offer} of the network (such as schedules) and sometimes the real-time {\em demand} (current traffic conditions). In contrast, our approach aims at satisfying query needs about the historical demand over a large collection of past trajectories collected from users.
    
    %As we start handling and storing all those huge amounts of transport information we run into a popular problem nowadays: managing and exploiting big data. This problem has been analyzed  from several perspectives and a significant number of papers about this topic have been presented \cite{bigdataIOT,bigdataBIO}. In the context of public transport the issue is even worse due to the spatio-temporal nature of the knowledge. Spatio-temporal big data is a quite recent research topic that not only needs to deal with how a huge amount of spatial information should be stored and administered \cite{richter12} but also needs to review how this data should be displayed \cite{cortinas18,pelekis11}. Therefore, in this area we have to deal with two important problems: not only processing massive amounts of geographical information efficiently is required, but also developing user-friendly interfaces to access and visualize them are necessary \cite{7363974,LI2016119}.
    
    
    When dealing with vast amounts of historic traveler data, a valid first approach to tackle its analysis is to extend a traditional \gls{dbms} that could both assimilate and handle greater volumes of spatial data. A popular tool that fits in this description would be \textit{postGIS},\footnote{\url{https://postgis.net/}} a spatial extension for the widely adopted relational DBMS \textit{PostgreSQL}. 
    However, these solutions that include spatial indices are not the most adequate for our information needs, that are many times unrelated to a geographic component, but to the network elements and their relationships (``how many travelers started their trip at a stop X using line L to end it at a stop Y within the time frame T?''), while the large sizes of our data collections would force us to use solutions based on secondary memory, considerably affecting the performance of the system.
    
    %\ojo{Deberíamos falar de solucions distribuidas, que usen BD NoSQL,... botar un ollo a isto: \cite{XYGL2018}}
    
    
    
    %Apart from providing an efficient representation for the underlying data, there also exists the need for supporting visualization, exploitation, and management of spatial data by external users. The research in these topics is relatively new, meaning that, to our best knowledge, there does not exist a standard model of representation. Even though normally the users of applications that handle transportation-oriented data have advanced knowledge of geoinformatics, our target is to design a user-friendly interface that would not require of such skills, but only the minimum necessary understanding of the transportation domain.
    
    
    
    %In this work, we focus in the problem of managing data from a public transport system and we present a tool that includes a user-friendly interface to simplify the visualization and exploitation of the underlying data.  Our tool takes advantage of the recent \gls{xctr}\ structure presented in \cite{daniil18} that uses compact data structures to represent the data related to user's trips and efficiently solves some queries on aggregated data. This permitted us not only to save storage space but also boosted query performance when solving some important queries from a public transportation management system. 
    %To the best of our knowledge, it is the first tool that uses a representation of the data based on compact data structures.
    %While there exist other previous works that make use of compact data structures to efficiently index large collections of in-network trajectories \cite{brisaboa2018compact, koide2018cinct,  koide15}, the recent \gls{xctr}\ solution in \cite{daniil18} is novel as it implements a conceptual model that could adapt to any particular transportation system. To decrease the redundancy in the representation of user's trajectories, instead of listing all the stops traversed along a user's trip, \gls{xctr}\ stores only the stops where a user boards a vehicle along a whole trip that chains several lines, and the intermediate stops may be easily deduced from the network representation. 
    
    Given that we are focusing on a tool specifically for public transportation networks, our interface is built over the \gls{xctr} (introduced in the Section~\ref{sec:newctr:str:xctr}), which has allowed us to achieve fast response times in our tested use cases. In any case, our proposed tool is flexible enough to allow data to be represented in a more traditional way, such as with a relational \gls{dbms}.
	
	\section{Architecture}
	In this section we discuss the overall architecture of Trippy, our interface based on \gls{xctr}. We start by describing it from the functional perspective, following the data flow from the data sources until the presentation in the user interface. We complement this description with a technical architecture overview, speaking about how the individual components are integrated together and facilitate an understanding of the decisions behind the technological choices.
	
	\subsection{Functional architecture}
	We have designed Trippy to be as flexible as possible, ensuring that it can operate with any network and trip descriptions that can be adapted to the model from the Figure~\ref{fig:er}, which is elementary enough to apply to most of the current transportation systems. For an overview of this data flow, refer to the diagram in the Figure~\ref{fig:arch:functional}.
	
	\begin{figure}[ht]
		\begin{center}
			{\includegraphics[width=0.75\textwidth]{figures/funcional_trippy.eps}}
		\end{center}
		\caption{Functional architecture of Trippy.}
		\label{fig:arch:functional}
	\end{figure}
	
	Although our system is oblivious to the specific data sources, we have successfully experimented adapting information collected from \gls{gtfs} sources, as well as OpenStreetMap, to obtain a description of a public transportation network. Each different source or format would require a custom conversion to adapt it to our model, which is one of the reasons that we had for standing against overcomplicating our model. As for the passenger trips, they must be described in terms of stages (boarding and alighting pairs) that are related to stops and journeys. The amount of preprocessing needed will depend on the source of the data, as most \gls{afc} systems do not directly record the alightings and the specific journey within the day will have to be estimated based on timestamps.
	
	We have also opted for different persistence options for the network description and the passenger trips, as we are interested in using our \gls{xctr} for the later, while the former does not pose any technological challenges that would warrant the use of a compact representation.
	
	Finally, these two data repositories are used to feed an API over which requests can be made, which is going to be exploited by the user interface. The specific supported requests are discussed in the Section~\ref{sec:api}.
	
	\subsection{Technical architecture}
	We have designed and implemented the infrastructure needed to solve our query needs, which are focused on the usage of network elements, as previously explained in Section~\ref{sec:gis:intro}. 
	%It is also worth highlighting that apart from that main target of Trippy, the second challenge addressed in our system is to efficiently represent massive datasets of trajectories formed by user's trips along a public transportation network. 
	To visualize and query on these network elements, we need to work with a representation of the network itself. Specifically, we represent the model for trips over a public transport network shown in the Figure~\ref{fig:er}, extended with spatial attributes (gps coordinates) for the stops and lines. Implementing this model for networks does not pose any challenge, as this information is rather static (it is not expected to grow significantly) and only requires a small amount of space in comparison to passenger trips. Therefore, a \gls{rdbms} representation can be used  to represent the elements of the network. On the other hand, we use our compact representation \gls{xctr} for the trips, that we are going to rely on for most of our queries. The reduced size of this autoindexed representation allows us to keep it in primary memory, making it outperform any traditional indexing alternative that is based on secondary memory.

    The overall technical architecture of our proposal is presented in Figure~\ref{fig:arch:real}. In the bottom part, we can find the backend
    %Before we explain each component in detail, we present a diagram for the overall architecture in Figure~\ref{fig:arch}. It is based on 
    that includes two sources of information: the former one includes the network representation and relies on a small read-only database implemented in SQLite\footnote{\url{https://sqlite.org/index.html}}; the other source includes a \gls{xctr}, for our compact representation of the passenger trips.
	
	\begin{figure}[ht]
		\begin{center}
			{\includegraphics[width=0.5\textwidth]{figures/tview.png}}
		\end{center}
		\caption{Technical architecture of Trippy.}
		\label{fig:arch:real}
	\end{figure}
	
	The backend is implemented in the Go language, and provides a uniform API to query the information sources. This is accessed by our GIS frontend (top of Figure~\ref{fig:arch:real}), which is in charge of displaying the transport network on a web map and allows the final user to make queries by interacting with the elements of the map and its controls.

    Further details about the elements included in both the backend and the frontend of Trippy\ are discussed below.
    
    \subsubsection{\bf Representing the transport network (SQLite).}
    Since we aim at visualizing the elements of the network over a map, we need information regarding the stops and lines of the transport network, following closely the model from the Figure~\ref{fig:er}. For each physical stop, along with the GPS coordinates of its location, we store a unique numeric identifier. Regarding the lines of the transport network, we basically keep the sequence of stops each line traverses. Note that, unlike the abstractions used by most public transportation networks, we consider lines to be one-way (i.e. they have a unique direction), and consequently the reversed/returning path is treated as a different line.
    
    As indicated above, we have chosen  a SQLite database to represent the network because it is conveniently portable and efficient for such small datasets. No spatial database technology was required as the only spatial property we have to deal with are the GPS coordinates of the  stops.
    
    \subsubsection{\bf GO handler.}
    This component has two main parts. On one hand, it implements a {\em REST API} that is used to obtain the collection of stops and lines in GeoJSON format. On the other hand, it also provides a querying interface for \gls{xctr}. While the query functions themselves are implemented in \gls{xctr} using {\em C++}, we have opted for {\em Go} as our main backend language because it is specifically oriented for web services and can be easily integrated with {\em C} code. In our case, we have implemented a thin {\em C wrapper} that interacts with the \gls{xctr} libraries to load \gls{xctr} structures (when the application is launched it loads the \gls{xctr}-based representation of the trips into memory) and handle calls to the query functions.
    
    \subsubsection{\bf Map viewer.}
    The Map viewer in Trippy makes up the user interface. It is in charge of visualizing the elements of the network, and handles users’ interaction. Apart from typical functions to move around a map (i.e. zoom in/out, span, etc.), the user can interact with the elements within the map (e.g. a stop or a set of stops within a region) and access functions related to them. Those functions are supported by our backend.
    
    The Map viewer was built with a web map using the {\em Leaflet} library\footnote{\url{https://leafletjs.com}} . With this library, it is simple to make an interactive map consisting of several interchangeable \gls{wms} and vector layers, and also to efficiently represent thousands of points or other vector-type elements.
    For additional controls, communication with the backend, state synchronization among our implemented controls and the map, we have used Vue.js\footnote{\url{https://vuejs.org}}, which is a popular web framework based on components.

	
	\section{API}
	\label{sec:api}
    As previously seen in the Section~\ref{sec:newctr:algo:analysis}, by basing our interface on \gls{xctr} we are able to solve a broad range of transport-related queries, including but not limiting to:

    \begin{itemize}
    %\item[\textbf{Transport Load Queries}]
    %\item How many passengers boarded or alighted on a particular stop?
    \item How many passengers boarded or alighted on a particular stop during a specific time interval (e.g. this evening, yesterday)?
    %\item How many passengers were on a given bus in a particular moment?
    %\item At what time is a specific stop more crowded?
    %\item[\textbf{Travel Pattern Queries}]
    \item How frequently is a stop X used to switch lines during rush hours?
    \item How many passengers started/ended their trips at a specific stop X?
    \item How many passengers started their trips at stop X and ended them at stop Y during a given time interval?
    \item How many travelers had to switch lines to get to their destination during a given time interval?
    \item How many times a line is used as a start or end of a trip? Alternatively, how many times is the line used to switch between two other lines, but not as an origin nor final destination?
    %\item Calculate the arithmetic mean \ojo{llenar con algo verídico}
    \end{itemize}
    
    Along with these basic queries supported originally by \gls{xctr}, in this work, we have extended its functionality to also support a range of more complex queries that were  solved as a combination of the previous ones:
    
    \begin{itemize}
        \item How many passengers traveled from area A to area B during a time interval? 
        \item At what time is a specific stop more crowded?
        \item At what time does a line get more crowded?
        %\item What extent of the city can be reached within one hour from a certain residential area during the morning rush hour?
    \end{itemize}
    
    To support these queries, we have developed API Endpoints that we are going to discuss in the rest of this section. Note that a single request will frequently be responsible for more than one kind of query, as we it is often more practical and efficient to perform multiple types queries over the same element in \gls{xctr} for one single API request.
    
    \subsection{Stops endpoint}
    This endpoint is implemented as an {\em HTTP GET} request with the format \texttt{/stop/X}, where \texttt{X} corresponds to the queried stop identifier. This request returns the following information of the stop \texttt{X}:
    
    \begin{itemize}
        %\item The name of the stop.
        %\item The identifiers of the lines this stop belongs to.
        \item Number of passengers that had boarded.
        \item Number of times the stop was used to start a trip.
        \item Number of times the stop was used to end a trip.
    \end{itemize}
    
    Additionally, this request accepts parameters to restrict the \textit{line identifier}, \textit{lower time limit} and \textit{upper time limit}, which will filter the numerical results mentioned above.
    
    When this endpoint is queried with no parameters (\texttt{/stop/}), it will return the list of all the stops in the network, which is needed to display them on a map and initialize the interface components. Consequently, the information for each stop returned by this query will consist of the following fields:
    
    \begin{itemize}
        \item Identifier.
        \item Name of the stop.
        \item Identifiers of the lines this stop belongs to.
        \item Geographical coordinates of the location of the stop.
    \end{itemize}
    
    \subsection{Lines endpoint}
    As with stops, there also exists a line endpoint that accepts {\em HTTP GET} requests of \texttt{/line/X}, being \texttt{X} the identifier of a line. The information returned is also the equivalent of the one returned by the stop endpoint, but concerning a whole line instead of a single stop:
    
    \begin{itemize}
        \item Number of passengers that had boarded (and alighted).
        \item Number of times the line was used to start a trip.
        \item Number of times the line was used to end a trip.
    \end{itemize}
    
    This endpoint accepts filtering by a time interval with the parameters of \textit{upper and lower time limits}.
    
    There is also the listing request \texttt{/line/}, to obtain a list of existing lines with the following fields:
    
    \begin{itemize}
        \item Identifier.
        \item Name of the line.
        \item Identifiers of the stops this line contains, in order.
        \item If exists, the path of the line, encoded as a sequence of coordinates\footnote{This information is optional, without it a line on the map can be displayed by simply connecting points with a straight line (which may not follow any road or track) or using an existing \gls{wms} layer with lines.}.
    \end{itemize}
    
    \subsection{Trips endpoint}
    This endpoint is dedicated to return one single field: the number of trips that have started at any of the stops from \texttt{X$^*$} to finally end at any stop from \texttt{Y$^*$}, where both \texttt{X$^*$} and \texttt{Y$^*$} can be either a single stop or a collection of them. Due to technical reasons\footnote{The requests my contain thousands of stops, surpassing the length limits of {\em GET} requests in many web servers, proxies and even browsers.}, this requests are implemented using the {\em POST} method over the \texttt{/trip} endpoint.
    
    Both \texttt{X$^*$} and \texttt{Y$^*$} can be restricted by a \textit{line} parameter (one line for starting stops and another for ending) and also \textit{lower and upper times} (starting or ending times of the trip contained within the limits). These requests can be noticeably slow when the number of queried stops is very high (in the order of thousands).
    
    \subsection{Histograms endpoints}
    These are two endpoints that handle {\em HTTP GET} requests about time series of boarding events either for a stop (\texttt{/hstop/X}) or a line (\texttt{/hline/X}). The returned data is a sequence of pairs $<t,n>$, where $t$ is a timestamp and $n$ is the number of boardings for that timestamp.
    
    There request may be bound to a time window (by specifying \textit{lower and upper time limits}, as in the other endpoints) and also accepts an additional parameter of \textit{sampling} that, if present, will group the number boardings by a set number of seconds $s$ into bins, each time $t$ delimiting the start of a new bin that will correspond to the period $[t..t+s)$. A reasonably large sampling parameter may not only save bandwidth as less information needs to be transmitted, but also speed up the request\footnote{In \gls{xctr}, a large sampling value may translate into more than one journey code for a line, thus making it possible to return a result before reaching the last level of the \texttt{WMJ} in the $\cnt$ operation.}.
	
	\section{User Interface}
	\label{sec:ui}
	With a lot of screencaps that are going to take like 10 pages! Maybe even an evaluation section (which would require me to make it actually work well!).
	
	We aimed at providing an accessible and intuitive user interface for Trippy. Its main view is presented in Figure~\ref{fig:genericLines} (in the following examples we show some screenshots from the case study in Section~\ref{proof}; i.e. trips on bus in Madrid). % it is shown a generic view of the interface. \ojo{Decir que en la genérica se puden pinchar las líneas para tener alguna info o algo así / en caso contrario sacarla porque no aporta demasiado esta figura}
    The interface of Trippy consists of a map with all the {\em bus stops} represented as blue points and the different {\em bus lines}  represented as colored lines. The user can select those elements to obtain related information. In addition, Four spatial/temporal filters allow the user to refine the displayed data, filtering by stops or time and one additional filter enables the user to refine results by line. The {\em filtering-by-stop} area allows to restrict queries to a given starting or ending stop (we can either look for their name in the filtering boxes or select them within the map). Besides, we can also provide a {\em filtering-by-datetime} which restricts also those queries to the specified starting and ending timestamps. For example, in Figure~\ref{fig:trippyIntDesc} we are querying the number of users that ``{\em boarded into a vehicle; switched-line; started a trip; ended a trip}" at the stop named {\em ``Juan de Toledo - Estaci\'on de buses"} from {\em `2019-03-12@16:00h'} to {\em `2019-03-13@16:00h'} searching on any line going through this point.
    
    Trippy\ supports all the interesting transport managing queries described in the Section~\ref{sec:api}. Among them, we have also given support for new aggregation queries not defined in \cite{daniil18} such as ``\textit{How many passengers moved from one region to another}".
     %
    %The interesting transport managing queries that supports Trippy\ where described in Section~\ref{ourQueries}. Among all the queries supported, b
    Below we discuss how an user could invoke three representative queries and how they would be executed on the viewer:
    
    \begin{itemize}
        \item \textbf{Stop information:} This query can be made either by selecting a point directly on the map or by searching for the name of a particular bus stop on the first assisted search text box (i.e. filter by starting start/stop area). As a result, a pop up box is immediately displayed over the selected point. This pop up shows the name of the stop, the number of passengers that boarded there, the number of passengers that switched bus in that stop and the amount of people that started or ended their trip at this location. It also includes average number of times the stop was boarded, trips were started and ended per bus journey (that is, for each time a bus stops at that stop).
        
        Below this information it also appears a button that allow to display another pop-up window with a breakdown of this information by journey, making it possible to analyze the load of a particular stop over the different hours of the day.
    
        Optionally, these results can be constrained to time interval by applying the time filters as shown in Figure~\ref{fig:trippyIntDesc}. 
        
        
        \item \textbf{Trajectories/Trips between two stops:} In this case our goal is to solve the queries responsible for counting the number of trips done between two bus stops. The user just needs to type the name of both stops on the text boxes and a line describing the trajectory will appear joining the starting point and the final one going through all the intermediate stops. As it is shown in \ref{fig:traj}, this line can have \textit{blank spaces} as it considers switches between lines that could not be at the same stop (i.e., a passenger gets off in one stop, crosses the street and gets on in a bus from another line). A pop up also appears near the line showing the total amount of trips that meet the requirements. In addition, those results can also be filtered out by time.
        
        
        \item \textbf{Displacements between areas:} Even though in \cite{daniil18} \gls{xctr}\ was not including the possibility of aggregating the number of users that started a trip in a spatial region and ended such trip in another region, we have now included this new query in Trippy.  Note that since the operation is not directly supported by \gls{xctr}, we are forced to obtain the number of trips for each pair of stops $\langle s_i,s_e\rangle$, where $s_i$ is a stop within the starting region (with $n$ stops), and $s_e$ is a stop within the ending region (with $m$ stops). Even though we have to perform $n \times m$ of those queries, the efficiency of \gls{xctr}\ at solving such queries ensured reduced response times.  %One of the main contributions of this study. This query was not possible in the previous work where the structures used in the lower level were described.
        
        Recall that the goal of this operation is to find the number of passengers that have traveled from one area or neighborhood to another. For that purpose, the user just needs to press the  {\sc shift-key} on the keyboard and select with the pointer the areas of interest, first the origin and then the destination. An arrow joining the two areas will appear, and a a pop-up showing the number of trips that fulfill the criteria will be displayed. Once again, this query can be refined with the time filters. A visual example is shown in Figure~\ref{fig:areas}.
    \end{itemize}